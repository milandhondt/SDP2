package domain;

import java.io.Serializable;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import exceptions.InformationRequiredExceptionAddress;
import exceptions.InformationRequiredExceptionSite;
import exceptions.InvalidInputException;
import interfaces.Observer;
import interfaces.RequiredElement;
import interfaces.Subject;
import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import jakarta.persistence.Transient;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import util.RequiredElementSite;
import util.Status;

/**
 * Represents a physical site/location containing machines and managed by a
 * responsible user. Implements the Subject interface for observer pattern
 * functionality.
 */
@Getter
@Table(name = "sites")
@Entity
@NoArgsConstructor
public class Site implements Serializable, Subject
{
	private static final long serialVersionUID = 1L;

	/**
	 * Set of observers that are monitoring changes to this site. Marked as
	 * transient as it doesn't need to be persisted.
	 */
	@Transient
	private Set<Observer> observers = new HashSet<>();

	/**
	 * Unique identifier for the site. Automatically generated by the database.
	 */
	@Setter
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;

	/**
	 * The name of the site. Cannot be null or empty.
	 */
	private String siteName;

	/**
	 * The user responsible for this site. Maintains a many-to-one relationship with
	 * User entity. Cascade persist is enabled for this relationship.
	 */
	@ManyToOne(cascade = CascadeType.PERSIST)
	@JoinColumn(name = "VERANTWOORDELIJKE_ID")
	private User verantwoordelijke;

	/**
	 * The physical address of this site. Maintains a many-to-one relationship with
	 * Address entity. Cascade persist is enabled for this relationship.
	 */
	@Setter
	@ManyToOne(cascade = CascadeType.PERSIST)
	@JoinColumn(name = "ADDRESS_ID")
	private Address address;

	/**
	 * Set of machines located at this site. Maintains a one-to-many bidirectional
	 * relationship with Machine entity. Uses eager fetching to load machines when
	 * the site is loaded.
	 */
	@OneToMany(mappedBy = "site", fetch = FetchType.EAGER)
	private Set<Machine> machines = new HashSet<>();

	/**
	 * Current status of the site. Persisted as a string in the database.
	 */
	@Enumerated(EnumType.STRING)
	private Status status;

	/**
	 * Constructs a new Site with all fields including ID (typically used when
	 * reconstructing existing entities).
	 *
	 * @param id                the unique identifier for the site
	 * @param siteName          the name of the site (cannot be empty)
	 * @param verantwoordelijke the responsible user for this site (cannot be null)
	 * @param status            the current status of the site (cannot be null)
	 * @param address           the physical address of the site (cannot be null)
	 */
	private Site(Builder builder)
	{
		this.siteName = builder.siteName;
		this.address = builder.address;
		this.verantwoordelijke = builder.verantwoordelijke;
		this.status = builder.status;
		this.machines = builder.machines;
		this.address = builder.address;
	}

	/**
	 * Sets the name of the site and notifies observers of the change.
	 *
	 * @param siteName the new name for the site (will be trimmed)
	 * @throws InvalidInputException if siteName is null or empty
	 */
	public void setSiteName(String siteName) throws InvalidInputException
	{
		if (siteName == null || siteName.trim().isEmpty())
		{
			throw new InvalidInputException("Site name cannot be null or empty");
		}
		this.siteName = siteName.trim();
		notifyObservers("");
	}

	/**
	 * Sets the responsible user for this site and notifies observers.
	 *
	 * @param verantwoordelijke the new responsible user (cannot be null)
	 * @throws InvalidInputException if verantwoordelijke is null
	 */
	public void setVerantwoordelijke(User verantwoordelijke)
	{
		if (verantwoordelijke == null)
		{
			throw new InvalidInputException("Site verantwoordelijke can not be null!");
		} else
		{
			this.verantwoordelijke = verantwoordelijke;
		}
		notifyObservers("");
	}

	/**
	 * Sets the status of the site and notifies observers.
	 *
	 * @param status the new status for the site (cannot be null)
	 * @throws InvalidInputException if status is null
	 */
	public void setStatus(Status status)
	{
		if (status == null)
		{
			throw new InvalidInputException("Site status can not be null!");
		} else
		{
			this.status = status;
		}
		notifyObservers("");
	}

	public Set<Machine> getMachines()
	{
		return this.machines.stream().collect(Collectors.toUnmodifiableSet());
	}

	/**
	 * Adds a machine to this site and ensures bidirectional relationship is
	 * maintained.
	 *
	 * @param machine the machine to add to this site
	 */
	public void addMachine(Machine machine)
	{
		machines.add(machine);
		if (machine.getSite() != this)
		{
			machine.setSite(this);
		}
	}

	@Override
	public void addObserver(Observer o)
	{
		observers.add(o);
	}

	@Override
	public void removeObserver(Observer o)
	{
		observers.remove(o);
	}

	@Override
	public void notifyObservers(String message)
	{
		observers.forEach(observer -> {
			observer.update(message);
		});
	}

	/**
	 * Builder class for constructing Site objects with validation. Implements the
	 * Builder pattern to create Site instances with required fields.
	 */
	public static class Builder
	{
		private String siteName;
		private Address address;
		private User verantwoordelijke;
		private Status status;
		private Set<Machine> machines = new HashSet<>();

		Map<String, RequiredElement> requiredElements = new HashMap<>();

		/**
		 * Sets the site name in the builder.
		 *
		 * @param siteName the name of the site
		 * @return the builder instance for method chaining
		 */
		public Builder buildSiteName(String siteName)
		{
			this.siteName = siteName;
			return this;
		}

		/**
		 * Sets the address in the builder.
		 *
		 * @param address the physical address of the site
		 * @return the builder instance for method chaining
		 */
		public Builder buildAddress(String street, int number, int postalcode, String city)
		{
			try
			{
				this.address = new Address.Builder().buildStreet(street).buildNumber(number).buildPostalcode(postalcode)
						.buildCity(city).build();
			} catch (InformationRequiredExceptionAddress ire)
			{
				ire.getRequiredElements().forEach((k, v) -> requiredElements.put(k, v));
			}
			return this;
		}

		/**
		 * Sets the responsible user in the builder.
		 *
		 * @param verantwoordelijke the user responsible for the site
		 * @return the builder instance for method chaining
		 */
		public Builder buildVerantwoordelijke(User verantwoordelijke)
		{
			this.verantwoordelijke = verantwoordelijke;
			return this;
		}

		/**
		 * Sets the status in the builder.
		 *
		 * @param status the status of the site
		 * @return the builder instance for method chaining
		 */
		public Builder buildStatus(Status status)
		{
			this.status = status;
			return this;
		}

		public Builder buildMachines(Set<Machine> machines)
		{
			this.machines = machines;
			return this;
		}

		/**
		 * Builds and validates the Site instance.
		 *
		 * @return the constructed Site instance
		 * @throws InformationRequiredExceptionSite if required fields are missing
		 */
		public Site build() throws InformationRequiredExceptionSite
		{
			validateRequiredFields();
			return new Site(this);
		}

		/**
		 * Validates that all required fields are present.
		 *
		 * @throws InformationRequiredExceptionSite if any required fields are missing,
		 *                                          containing a map of missing fields
		 *                                          and their requirements
		 */
		private void validateRequiredFields() throws InformationRequiredExceptionSite
		{
			if (siteName == null || siteName.isEmpty())
				requiredElements.put("siteName", RequiredElementSite.SITE_NAME_REQUIRED);

			// Verantwoordelijkheid naar de addres klasse schuiven en niet hier controlleren
			// de velden van adres!
			if (address == null)
				requiredElements.put("address", RequiredElementSite.ADDRESS_REQUIRED);

			// Verantwoordelijkheid naar de user klasse schuiven en niet hier controleren de
			// velden van employee!
			if (verantwoordelijke == null)
				requiredElements.put("employee", RequiredElementSite.EMPLOYEE_REQUIRED);

			if (status == null)
				requiredElements.put("status", RequiredElementSite.STATUS_REQUIRED);

			if (!requiredElements.isEmpty())
				throw new InformationRequiredExceptionSite(requiredElements);
		}
	}
}